#lang racket

;; 1.2
;; The ability to visualize the consequences of the actions under consideration
;; is crucial to becoming an expert programmer.
;; To become experts, we must learn to visualize the processes generated by
;; various type of procedures.
;; Only after we have developed such a skill can we learn to reliably
;; construct programs that exhibit the desired behaviour.

;; 1.2.1
;; - recursive process(再帰プロセス)
;; - iterative process(反復プロセス)
;; 再帰と反復の違い
;; 反復プロセスが再帰手続きにより記述されていても定量的な記憶域にて実行される.
;; この実装はtail-recursive(末尾再帰)と呼ばれる.
;; 
;; [末尾再帰(wiki)]
;; 自身の再帰呼び出しが、その計算における最後のステップになっているような
;; 再帰のパターンのことである.
;; 呼び出しではなく、戻り先を保存しないジャンプに最適化できるという特徴がある(末尾呼出最適化)

(require racket/trace)
(define (factorial n)
  (if (= n 1)
    1
    (* n (factorial (- n 1)))))
(trace factorial)
(factorial 5)

;; Result
;; >(factorial 5)
;; > (factorial 4)
;; > >(factorial 3)
;; > > (factorial 2)
;; > > >(factorial 1)
;; < < <1
;; < < 2
;; < <6
;; < 24
;; <120
;; 120


(require racket/trace)
(define (factorial n)
  (fact-iter 1 1 n))
(define (fact-iter product counter max-count)
  (if (> counter max-count)
    product
    (fact-iter (* counter product)
               (+ counter 1)
               max-count)))
(trace factorial)
(factorial 5)

;; Result
;; >(factorial 5)
;; <120
;; 120

;; Exercise 1.9

(require racket/trace)
(define (+ a b)
  (if (= a 0) b (inc (+ (dec a) b))))
(trace +)
(+ 3 3)
;; -> recursive process

(require racket/trace)
(define (+ a b)
  (if (= a 0) b (+ (dec a) (inc b))))
(trace +)
(+ 3 3)
;; -> iterative process

;; 1.2.2 tree recursion

;; Tree recursion Example
;; But it does so much redundunt computation
;; The process uses a number of steps that grows exponentially with the input.
(require racket/trace)
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
(trace fib)
(fib 5)

;; Iterative Example
(require racket/trace)
(define (fib n)
  (fib-iter 1 0 n))
(define (fib-iter a b count)
  (if (= count 0)
    b
    (fib-iter (+ a b) a (- count 1))))
(trace fib)
(fib 5)

;; 両替パターンを数えるアルゴリズム
(define (count-change amount) (cc amount 6))
(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount
                        (first-denomination kinds-of-coins))
                     kinds-of-coins)))))
(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 50)
        ((= kinds-of-coins 5) 100)
        ((= kinds-of-coins 6) 500)))
(count-change 200)

;; Exercise 1.11

;; recursive process
(define (f n)
  (if (< n 3)
    n
    (+ (f (- n 1))
       (* 2 (f (- n 2)))
       (* 3 (f (- n 3))))))
(f 20)

(require racket/trace)
(define (f n)
  (if (< n 3) n (f-iter 2 1 0 n)))
(define (f-iter a b c count)
  (if (< count 3)
    a
    (f-iter (+ a (* 2 b) (* 3 c))
            a
            b
            (- count 1))))
(trace f)
(f 20)

;; Exercise 1.12

;; version 1
(require racket/trace)
(define (triangle-vals vals idx)
  (cond ((= idx 0)
         (append (list (car vals)) (triangle-vals vals (+ idx 1))))
        ((= (length vals) 1)
         (list (car vals)))
        (else
          (append 
            (list (+ (car vals) (car (cdr vals))))
            (triangle-vals (cdr vals) (+ idx 1))))))
(define (triangle-vals-iter vals n k)
  (if (= k n)
    vals
    (triangle-vals-iter (triangle-vals vals 0) n (+ k 1))))
(define (print-triangle-iter n k)
  (display (format "~a~n" (triangle-vals-iter '(1) k 0)))
  (if (= k n)
    (display "")
    (print-triangle-iter n (+ k 1))))
(define (pascal-triangle n)
  (print-triangle-iter n 0))
(pascal-triangle 3)

;; version 2
(define (pt column row)
  (cond ((= column 0) 1)
        ((= row column) 1)
        (else 
          (+ (pt (- column 1) (- row 1)) (pt column (- row 1))))))
(display (format "~a" (pt 0 0)))
(display (format "~a ~a" (pt 0 1) (pt 1 1)))
(display (format "~a ~a ~a" (pt 0 2) (pt 1 2) (pt 2 2)))

;; 1.2.3 増加のオーダー
;; - order of growth
;; It's useful for explaining the difference of the amount
;; of resources that the processes consume.
;; 補足)プロセスが消費するリソース(資源)の相対的量を得るための記法

;; 1.2.4 指数計算

;; Recursive Process
;; order(n), memory(n)
(define (expt b n)
  (if (= n 0)
    1
    (* b (expt b (- n 1)))))
(expt 2 3)

;; Iterative Process
;; order(n), memory(1)
(define (expt b n)
  (expt-iter b n 1))
(define (expt-iter b counter product)
  (if (= counter 0)
    product
    (expt-iter b
               (- counter 1)
               (* b product))))
(expt 2 8)

;; Improved Version
;; order(log n) = 対数ステップ数のアルゴリズム
(define (square n) (* n n))
(define (fast-expt b n)
  (cond ((= n 0) 1)
        ((even? n) (square (fast-expt b (/ n 2))))
        (else (* b (fast-expt b (- n 1))))))
(fast-expt 2 8)

;; 1.2.5 最大公約数(Greatest Common divisor)(GCD)
;; Euclid's Algorithm(ユークリッドの互除法)

; 下記は反復プロセスを生成し, ステップ数は与えられた数値の対数で増加する
(define (gcd a b)
  (if (= b 0)
    a
    (gcd b (remainder a b))))
(gcd 16 24)

;; 1.2.6 素数判定

;; find-divisorの終了条件は, もしnが素数でないならば√nより小さいか
;; または等しい約数を持つという事実に基づく
;; このアルゴリズムでは1から√nまでの約数についてのみテストすれば良い
;; 結果として, nが素数であるかを判定するのに必要なステップ数の
;; 増加のオーダーはΘ(√n)となる.
(define (square n) (* n n))
(define (smallest-devisor n) (find-divisor n 2))
(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))
(define (divides? a b) (= (remainder b a) 0))
(define (prime? n)
  (= n (smallest-devisor n)))
(prime? 4294967087)

(prime? 3)
; (prime? 3)
; (= 3 (smallest-devisor 3)
; (= 3 (find-divisor 3 2))
; (= 3 (cond ((> (square 2) 3) 3)
;            ((divides? 2 3) 2)
;            (else (find-divisor 3 (+ 2 1)))))
; (= 3 (cond ((> 4 3) 3)
;            ((divides? 2 3) 2)
;            (else (find-divisor 3 (+ 2 1)))))
; (= 3 3)
; true
(prime? 5)
; (prime? 3)
; (= 5 (smallest-devisor 5)
; (= 5 (find-divisor 5 2))
; (= 5 (cond ((> (square 2) 5) 5)
;            ((divides? 2 5) 2)
;            (else (find-divisor 5 (+ 2 1)))))
; (= 5 (cond ((> 4 5) 5)
;            ((divides? 2 5) 2)
;            (else (find-divisor 5 (+ 2 1)))))
; (= 5 (cond (false 5)
;            ((divides? 2 5) 2)
;            (else (find-divisor 5 (+ 2 1)))))
; (= 5 (cond (false 5)
;            ((= (remainder 5 2) 0) 2)
;            (else (find-divisor 5 (+ 2 1)))))
; (= 5 (cond (false 5)
;            ((= 1 0) 2)
;            (else (find-divisor 5 (+ 2 1)))))
; (= 5 (cond (false 5)
;            (false 2)
;            (else (find-divisor 5 (+ 2 1)))))
; (= 5 (cond (false 5)
;            (false 2)
;            (else (find-divisor 5 3))))
; (= 5 (cond (false 5)
;            (false 2)
;            (else (cond ((> (square 3) 5) 5)
;                        ((divides? test-divisor 5) 3)
;                        (else (find-divisor 5 (+ 3 1))))))))
; (= 5 (cond (false 5)
;            (false 2)
;            (else (cond ((> 9 5) 5)
;                        ((divides? test-divisor 5) 3)
;                        (else (find-divisor 5 (+ 3 1))))))))
; (= 5 (cond (false 5)
;            (false 2)
;            (else (cond (true 5)
;                        ((divides? test-divisor 5) 3)
;                        (else (find-divisor 5 (+ 3 1))))))))
; (= 5 (cond (false 5)
;            (false 2)
;            (else 5)
; (= 5 5)
; true 
(prime? 6)
; (prime? 6)
; (= 6 (smallest-devisor 6)
; (= 6 (find-divisor 6 2))
; (= 6 (cond ((> (square 2) 6) 6)
;            ((divides? 2 6) 2)
;            (else (find-divisor 6 (+ 2 1)))))
; (= 6 (cond ((> (square 2) 6) 6)
;            ((divides? 2 6) 2)
;            (else (find-divisor 6 (+ 2 1)))))
; (= 6 (cond ((> 4 6) 6)
;            ((divides? 2 6) 2)
;            (else (find-divisor 6 (+ 2 1)))))
; (= 6 (cond ((> 4 6) 6)
;            ((= (remainder 6 2) 0) 2)
;            (else (find-divisor 6 (+ 2 1)))))
; (= 6 (cond ((> 4 6) 6)
;            ((= 0 0) 2)
;            (else (find-divisor 6 (+ 2 1)))))
; (= 6 2)
; false

;; フェルマーテスト
;; Θ(log n)の素数判定はフェルマーの小定理に基づく
;; 
;; Fermat's Little Theorem(フェルマーの少定理):
;; nが素数かつaがnより小さい任意の正の整数であるとき,
;; aのn乗は法nに関してaと合同である.
;; 
;; 2つの数値の両方をnで割った時に同じ余りを持つ場合, "法nに関して合同"と呼ぶ
;; 英語ではcongruent modulo nと呼ぶ
;; aをnで除算したときの剰余をremainder of a modulo nと言う
;; 簡潔には, a modulo nと言う.

(require racket/trace)
(define (square n) (* n n))
(define (expmod base exp m)
  (cond ((= exp 0)
         1)
        ((even? exp)
         (remainder
           (square
             (expmod base (/ exp 2) m))
           m))
        (else
          (remainder
            (* base
               (expmod base (- exp 1) m))
            m))))
(define (fermat-test n)
  (define (try-it a)
    (display (format "a: ~a\n" a))
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))
(define (fast-prime? n times)
  (cond ((= times 0) true)
        ((fermat-test n) (fast-prime? n (- times 1)))
        (else false)))
(trace expmod)
(fast-prime? 5 1)

; 指数 e が 1 より大きい場合の縮小ステップは、任意の整数 x, y, m に対し
; x modulo m と y modulo m を別々に求め、これらを掛け、
; その結果の法 m に関する剰余を求める ことで (x と y の積 modulo m) を
; 求めることができるという事実に基づきます。
; 例えば e が偶数の場合に b^(e/2) modulo m を求め、その二乗を取り、
; 法 m に関する剰余を得ます。 このテクニックはとても役に立ちます。
; m よりもはるかに大きな数値を一切扱う必要無 しに演算を行うことが可能だからです。

;; 例) mod(3^4, 5) = mod(mod(3^3, 5)*3, 5) = 1
;; 例) mod(3^4, 5) = mod(mod(3^2, 5)^2, 5) = 1

;; Exercise 1.21
(define (square n) (* n n))
(define (smallest-devisor n) (find-divisor n 2))
(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))
(define (divides? a b) (= (remainder b a) 0))
(smallest-devisor 199)
(smallest-devisor 1999)
(smallest-devisor 19999)

;; Exercise 1.22

(define (timed-prime-test n)
  (newline) (display n) (start-prime-test n (runtime)))
(define (start-prime-test n start-time)
  (if (prime? n)
    (report-prime (- (runtime) start-time))))
(define (report-prime elapsed-time)
  (display " *** ") (display elapsed-time))
(define (square n) (* n n))
(define (smallest-devisor n) (find-divisor n 2))
(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))
(define (divides? a b) (= (remainder b a) 0))
(define (prime? n)
  (= n (smallest-devisor n)))
(define (search-for-primes start end)
  (cond ((> start end) (newline) (display 'finished))
        ((< start 2) (search-for-primes 2 end))
        (else
         (timed-prime-test start)
         (search-for-primes (+ start (if (even? start) 1 2)) end))))

(search-for-primes 1000 1030)

(search-for-primes 10000 10040)

(search-for-primes 100000 100050)

(search-for-primes 100000 100150)

;; Exercise 1.23

(define (timed-prime-test n)
  (newline) (display n) (start-prime-test n (runtime)))
(define (start-prime-test n start-time)
  (if (prime? n)
    (report-prime (- (runtime) start-time))))
(define (report-prime elapsed-time)
  (display " *** ") (display elapsed-time))
(define (square n) (* n n))
(define (smallest-devisor n) (find-divisor n 2))
(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (next test-divisor)))))
(define (next n)
  (if (= n 2) 3 (+ n 2)))
(define (divides? a b) (= (remainder b a) 0))
(define (prime? n)
  (= n (smallest-devisor n)))
(define (search-for-primes start end)
  (cond ((> start end) (newline) (display 'finished))
        ((< start 2) (search-for-primes 2 end))
        (else
         (timed-prime-test start)
         (search-for-primes (+ start (if (even? start) 1 2)) end))))

(timed-prime-test 1009)
(timed-prime-test 1013)
(timed-prime-test 1019)
(timed-prime-test 1021)
(timed-prime-test 10007)
(timed-prime-test 10009)
(timed-prime-test 10037)
(timed-prime-test 10039)
(timed-prime-test 100069)
(timed-prime-test 100103)
(timed-prime-test 100109)
(timed-prime-test 100129)


;; Exercise 1.24

(define (timed-prime-test n)
  (newline) (display n) (start-prime-test n (runtime)))
(define (start-prime-test n start-time)
  (if (fast-prime? n 1000)
    (report-prime (- (runtime) start-time))))
(define (report-prime elapsed-time)
  (display " *** ") (display elapsed-time))
(define (square n) (* n n))
(define (expmod base exp m)
  (cond ((= exp 0)
         1)
        ((even? exp)
         (remainder
           (square
             (expmod base (/ exp 2) m))
           m))
        (else
          (remainder
            (* base
               (expmod base (- exp 1) m))
            m))))
(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))
(define (fast-prime? n times)
  (cond ((= times 0) true)
        ((fermat-test n) (fast-prime? n (- times 1)))
        (else false)))

(timed-prime-test 1009)
(timed-prime-test 1000003)
(timed-prime-test 1000000009)

;; Exercise 1.25

(define (timed-prime-test n)
  (newline) (display n) (start-prime-test n (runtime)))
(define (start-prime-test n start-time)
  (if (fast-prime? n 1000)
    (report-prime (- (runtime) start-time))))
(define (report-prime elapsed-time)
  (display " *** ") (display elapsed-time))
(define (square n) (* n n))
(define (expmod base exp m)
  (remainder (fast-expt base exp) m)) ; this is not working
  ;(cond ((= exp 0)
  ;       1)
  ;      ((even? exp)
  ;       (remainder
  ;         (square
  ;           (expmod base (/ exp 2) m))
  ;         m))
  ;      (else
  ;        (remainder
  ;          (* base
  ;             (expmod base (- exp 1) m))
  ;          m))))
(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))
(define (fast-prime? n times)
  (cond ((= times 0) true)
        ((fermat-test n) (fast-prime? n (- times 1)))
        (else false)))
(define (fast-expt b n)
  (cond ((= n 0) 1)
        ((even? n) (square (fast-expt b (/ n 2))))
        (else (* b (fast-expt b (- n 1))))))

(timed-prime-test 1009)
(timed-prime-test 1000003)
(timed-prime-test 1000000009)

;; Exercise 1.27

(define (timed-prime-test n)
  (newline) (display n) (start-prime-test n (runtime)))
(define (start-prime-test n start-time)
  (if (fast-prime? n 1000)
    (report-prime (- (runtime) start-time))))
(define (report-prime elapsed-time)
  (display " *** ") (display elapsed-time))
(define (square n) (* n n))
(define (expmod base exp m)
  (cond ((= exp 0)
         1)
        ((even? exp)
         (remainder
           (square
             (expmod base (/ exp 2) m))
           m))
        (else
          (remainder
            (* base
               (expmod base (- exp 1) m))
            m))))
(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))
(define (fast-prime? n times)
  (cond ((= times 0) true)
        ((fermat-test n) (fast-prime? n (- times 1)))
        (else false)))

;; prime numbers
(timed-prime-test 1009)
(timed-prime-test 1000003)
(timed-prime-test 1000000009)

;; Carmichael numbers
(timed-prime-test 561)
(timed-prime-test 1105)
(timed-prime-test 1729)
(timed-prime-test 2465)
(timed-prime-test 2821)
(timed-prime-test 6601)

(define (square n) (* n n))
(define (smallest-devisor n) (find-divisor n 2))
(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))
(define (divides? a b) (= (remainder b a) 0))
(define (prime? n)
  (= n (smallest-devisor n)))
(prime? 561)
(prime? 1105)
(prime? 1729)
(prime? 2465)
(prime? 2821)
(prime? 6601)

(define (test n)
  (test-congruent 2 n))
(define (test-congruent current n)
  (cond ((= current n)
         (display 'finished))
        ((= (expmod current n n) current)
         (test-congruent (+ 1 current) n))
        (else
          (display (format "~a is not congruent modulo ~a" current n)))))
(define (expmod base exp m)
  (cond ((= exp 0)
         1)
        ((even? exp)
         (remainder
           (square
             (expmod base (/ exp 2) m))
           m))
        (else
          (remainder
            (* base
               (expmod base (- exp 1) m))
            m))))
(test 561)
(test 1105)
(test 1729)
(test 2465)
(test 2821)
(test 6601)

;; Exercise 1.28

(define (square n) (* n n))
(define (expmod base exp m)
  (define (square-check x)
    (if (and (not (or (= x 1) (= x (- m 1))))
             (= (remainder (square x) m) 1))
      0
      (remainder (square x) m))))
  (cond ((= exp 0)
         1)
        ((even? exp)
         (square-check
           (expmod base (/ exp 2) m)))
        (else
          (remainder
            (* base
               (expmod base (- exp 1) m))
            m))))
(define (miller-rabin-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))
(define (fast-prime? n times)
  (cond ((= times 0) true)
        ((miller-rabin-test n) (fast-prime? n (- times 1)))
        (else false)))
(fast-prime? 21 10)
(fast-prime? 561 10)
(fast-prime? 1105 10)
(fast-prime? 1729 10)
(fast-prime? 2465 10)
(fast-prime? 2821 10)
(fast-prime? 6601 10)
(fast-prime? 10 10)
(fast-prime? 1009 10)
(fast-prime? 1000003 10)
(fast-prime? 1000000009 10)



